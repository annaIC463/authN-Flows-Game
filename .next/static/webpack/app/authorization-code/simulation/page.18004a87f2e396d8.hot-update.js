"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/authorization-code/simulation/page",{

/***/ "(app-pages-browser)/./lib/game/AuthCodeConstellation.ts":
/*!*******************************************!*\
  !*** ./lib/game/AuthCodeConstellation.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthCodeConstellation: () => (/* binding */ AuthCodeConstellation)\n/* harmony export */ });\nclass AuthCodeConstellation {\n    init(ctx, width, height) {\n        // Layout: Diamond Shape\n        // User (Bottom), App (Left), Auth (Top), API (Right) - roughly\n        // Actually, clearer: \n        // User (Bottom Center)\n        // App (Left Center)\n        // Auth (Right Center) -> No, Auth should be distinct.\n        // Let's do:\n        // App (Left), Auth (Right), API (Far Right)\n        // User (Bottom Center)\n        this.nodes = [\n            {\n                x: width * 0.2,\n                y: height * 0.5,\n                label: \"Client App\",\n                id: \"app\",\n                radius: 30,\n                type: 'server'\n            },\n            {\n                x: width * 0.5,\n                y: height * 0.3,\n                label: \"Auth0 Tenant\",\n                id: \"auth\",\n                radius: 35,\n                type: 'auth'\n            },\n            {\n                x: width * 0.8,\n                y: height * 0.5,\n                label: \"API\",\n                id: \"api\",\n                radius: 30,\n                type: 'resource'\n            },\n            {\n                x: width * 0.5,\n                y: height * 0.75,\n                label: \"User / Browser\",\n                id: \"user\",\n                radius: 25,\n                type: 'user'\n            }\n        ];\n        // Stars\n        this.stars = [];\n        for(let i = 0; i < 100; i++){\n            this.stars.push({\n                x: Math.random() * width,\n                y: Math.random() * height,\n                size: Math.random() * 2,\n                speed: Math.random() * 0.5 + 0.1\n            });\n        }\n    }\n    update(dt) {\n        this.time += dt;\n        this.updateConstellation(dt);\n    }\n    updateConstellation(dt) {\n        // State Machine Logic for Connections\n        for(let i = this.connections.length - 1; i >= 0; i--){\n            const conn = this.connections[i];\n            // Move packet\n            if (conn.progress < 1) {\n                conn.progress += dt * 0.3;\n            } else {\n                // Packet arrived\n                this.handlePacketArrival(conn);\n                this.connections.splice(i, 1); // Remove completed connection\n            }\n        }\n    }\n    handlePacketArrival(conn) {\n        if (conn.type === 'redirect' && conn.to.id === 'app') {\n            // User visited App. App responds with 302 Redirect.\n            // Visual effect: App pulses\n            this.state = 'REDIRECTING';\n            this.message = \"App responds: '302 Found'. Redirecting Browser to Auth0...\";\n            setTimeout(()=>{\n                const auth = this.nodes.find((n)=>n.id === 'auth');\n                const user = this.nodes.find((n)=>n.id === 'user');\n                if (auth && user) {\n                    this.connections.push({\n                        from: user,\n                        to: auth,\n                        progress: 0,\n                        type: 'redirect',\n                        label: 'Browser Redirect'\n                    });\n                }\n            }, 1000);\n        } else if (conn.type === 'redirect' && conn.to.id === 'auth') {\n            // User arrived at Auth Server (Step 1 Complete)\n            this.state = 'LOGIN_REQUIRED';\n            this.message = \"Step 2: User Logs In & Grants Consent\";\n            // Auto-trigger \"Login\" effect then send code back\n            setTimeout(()=>{\n                const auth = this.nodes.find((n)=>n.id === 'auth');\n                const user = this.nodes.find((n)=>n.id === 'user');\n                if (auth && user) {\n                    this.state = 'RETURNING_CODE';\n                    this.message = \"Step 3: Auth Server redirects User back with Code\";\n                    this.connections.push({\n                        from: auth,\n                        to: user,\n                        progress: 0,\n                        type: 'code',\n                        label: 'Auth Code' // Visible Code\n                    });\n                }\n            }, 1000);\n        } else if (conn.type === 'code' && conn.to.id === 'user') {\n            // User has code, needs to give to App\n            const user = this.nodes.find((n)=>n.id === 'user');\n            const app = this.nodes.find((n)=>n.id === 'app');\n            if (user && app) {\n                this.connections.push({\n                    from: user,\n                    to: app,\n                    progress: 0,\n                    type: 'code',\n                    label: 'Auth Code'\n                });\n            }\n        } else if (conn.type === 'code' && conn.to.id === 'app') {\n            // App received code. Now Back-channel exchange.\n            this.state = 'EXCHANGING';\n            this.message = \"Step 4: App exchanges Code for Token (Back-channel)\";\n            setTimeout(()=>{\n                const app = this.nodes.find((n)=>n.id === 'app');\n                const auth = this.nodes.find((n)=>n.id === 'auth');\n                if (app && auth) {\n                    this.connections.push({\n                        from: app,\n                        to: auth,\n                        progress: 0,\n                        type: 'exchange',\n                        label: 'Code + Secret'\n                    });\n                }\n            }, 500);\n        } else if (conn.type === 'exchange' && conn.to.id === 'auth') {\n            // Auth received valid code + secret. Return Token.\n            setTimeout(()=>{\n                const app = this.nodes.find((n)=>n.id === 'app');\n                const auth = this.nodes.find((n)=>n.id === 'auth');\n                if (app && auth) {\n                    this.connections.push({\n                        from: auth,\n                        to: app,\n                        progress: 0,\n                        type: 'token',\n                        label: 'Access Token'\n                    });\n                }\n            }, 500);\n        } else if (conn.type === 'token' && conn.to.id === 'app') {\n            // App has token!\n            this.state = 'AUTHORIZED';\n            this.message = \"Step 5: App uses Token to access API\";\n        } else if (conn.type === 'access' && conn.to.id === 'api') {\n            this.state = 'COMPLETE';\n            this.message = \"Flow Complete! Secure User Access Granted.\";\n        }\n    }\n    draw(ctx, width, height) {\n        this.drawConstellation(ctx);\n    }\n    drawConstellation(ctx) {\n        // Background Stars\n        ctx.fillStyle = \"rgba(255, 255, 255, 0.8)\";\n        this.stars.forEach((star)=>{\n            const opacity = 0.5 + Math.sin(this.time * star.speed) * 0.5;\n            ctx.globalAlpha = opacity;\n            ctx.beginPath();\n            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        ctx.globalAlpha = 1.0;\n        // Draw Front-End / Back-End Zones\n        const zoneY = ctx.canvas.height * 0.65;\n        // Separator Line\n        ctx.beginPath();\n        ctx.moveTo(0, zoneY);\n        ctx.lineTo(ctx.canvas.width, zoneY);\n        ctx.strokeStyle = \"rgba(255, 255, 255, 0.2)\";\n        ctx.setLineDash([\n            10,\n            10\n        ]);\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        ctx.setLineDash([]); // Reset\n        // Zone Labels\n        ctx.font = \"bold 14px Inter\";\n        ctx.fillStyle = \"rgba(255, 255, 255, 0.3)\";\n        ctx.textAlign = \"left\";\n        ctx.fillText(\"BACK-END (Trusted Zone)\", 20, zoneY - 15);\n        ctx.fillText(\"FRONT-END (Untrusted Zone)\", 20, zoneY + 25);\n        // Draw State/Message\n        ctx.font = \"bold 24px Inter, sans-serif\";\n        ctx.textAlign = \"center\";\n        if (this.state === 'COMPLETE') ctx.fillStyle = \"#4ade80\";\n        else if (this.state === 'AUTHORIZED') ctx.fillStyle = \"#facc15\";\n        else ctx.fillStyle = \"#e879f9\";\n        ctx.fillText(this.message, ctx.canvas.width / 2, 150);\n        // Connections & Packets\n        this.connections.forEach((conn)=>{\n            // Draw Line\n            ctx.beginPath();\n            ctx.moveTo(conn.from.x, conn.from.y);\n            ctx.lineTo(conn.to.x, conn.to.y);\n            ctx.strokeStyle = \"rgba(255, 255, 255, 0.2)\";\n            ctx.lineWidth = 2;\n            ctx.stroke();\n            // Draw Packet\n            const currentX = conn.from.x + (conn.to.x - conn.from.x) * conn.progress;\n            const currentY = conn.from.y + (conn.to.y - conn.from.y) * conn.progress;\n            // Packet Color\n            let glowColor = \"rgba(255, 255, 255, 1)\";\n            if (conn.type === 'code') glowColor = \"rgba(168, 85, 247, 1)\"; // Purple\n            if (conn.type === 'token') glowColor = \"rgba(250, 204, 21, 1)\"; // Yellow\n            // Packet Glow\n            const glow = ctx.createRadialGradient(currentX, currentY, 5, currentX, currentY, 20);\n            glow.addColorStop(0, glowColor);\n            glow.addColorStop(1, \"rgba(255, 255, 255, 0)\");\n            ctx.fillStyle = glow;\n            ctx.beginPath();\n            ctx.arc(currentX, currentY, 20, 0, Math.PI * 2);\n            ctx.fill();\n            // Packet Label\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"12px Inter\";\n            ctx.fillText(conn.label, currentX, currentY - 20);\n        });\n        // Draw Drag Line\n        if (this.activeNode && this.mousePos) {\n            ctx.beginPath();\n            ctx.moveTo(this.activeNode.x, this.activeNode.y);\n            ctx.lineTo(this.mousePos.x, this.mousePos.y);\n            ctx.strokeStyle = \"#ffffff\";\n            ctx.setLineDash([\n                5,\n                5\n            ]);\n            ctx.lineWidth = 2;\n            ctx.stroke();\n            ctx.setLineDash([]);\n        }\n        // Nodes\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        this.nodes.forEach((node)=>{\n            // Node Circle\n            ctx.beginPath();\n            ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);\n            // Dynamic node coloring\n            let color = \"#334155\";\n            let glowColor = \"rgba(148, 163, 184, 0.5)\";\n            // App Pulse on Redirect\n            if (this.state === 'REDIRECTING' && node.id === 'app') {\n                // Red Pulse\n                glowColor = \"rgba(239, 68, 68, 0.8)\";\n                color = \"#ef4444\";\n            }\n            if (node.type === 'user') {\n                color = \"#a855f7\";\n                glowColor = \"rgba(168, 85, 247, 0.5)\";\n            }\n            if (node.type === 'auth') {\n                color = \"#f59e0b\";\n                glowColor = \"rgba(245, 158, 11, 0.5)\";\n            }\n            if (node.type === 'server') {\n                color = \"#3b82f6\";\n                glowColor = \"rgba(59, 130, 246, 0.5)\";\n            }\n            // Glow animation\n            const glowSize = 10 + Math.sin(this.time * 3) * 5;\n            const gradient = ctx.createRadialGradient(node.x, node.y, node.radius, node.x, node.y, node.radius + glowSize);\n            gradient.addColorStop(0, glowColor);\n            gradient.addColorStop(1, \"rgba(0,0,0,0)\");\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.fillStyle = color;\n            ctx.beginPath();\n            ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);\n            ctx.fill();\n            // Border\n            ctx.strokeStyle = \"white\";\n            ctx.lineWidth = 2;\n            ctx.stroke();\n            // Label\n            ctx.fillStyle = \"#cbd5e1\";\n            ctx.font = \"14px Inter\";\n            ctx.fillText(node.label, node.x, node.y + node.radius + 20);\n            // Initials\n            ctx.fillStyle = \"white\";\n            ctx.font = \"bold 12px Inter\";\n            const initial = node.label.substring(0, 2);\n            ctx.fillText(initial, node.x, node.y);\n            // Draw \"302\" Text if Redirecting\n            if (this.state === 'REDIRECTING' && node.id === 'app') {\n                ctx.fillStyle = \"#ef4444\";\n                ctx.font = \"bold 16px Inter\";\n                ctx.fillText(\"302 Found\", node.x, node.y - 40);\n            }\n        });\n        // Instructions\n        ctx.fillStyle = \"#64748b\";\n        ctx.textAlign = \"left\";\n        ctx.font = \"14px Inter\";\n        ctx.fillText(\"Instructions: Drag from User to App to start.\", 20, ctx.canvas.height - 30);\n    }\n    onClick(x, y) {\n        if (this.state !== 'IDLE' && this.state !== 'AUTHORIZED') return; // Only allow interations at specific points\n        if (this.state === 'COMPLETE') return;\n        const clickedNode = this.nodes.find((node)=>{\n            const dx = node.x - x;\n            const dy = node.y - y;\n            return dx * dx + dy * dy < node.radius * 2 * node.radius * 2;\n        });\n        if (clickedNode) {\n            if (!this.activeNode) {\n                // START DRAG\n                // Rule 1: IDLE -> Start at User (simulating user clicking \"Login\")\n                if (this.state === 'IDLE' && clickedNode.id === 'user') {\n                    this.activeNode = clickedNode;\n                } else if (this.state === 'AUTHORIZED' && clickedNode.id === 'app') {\n                    this.activeNode = clickedNode;\n                }\n            } else {\n                // END DRAG\n                if (this.activeNode !== clickedNode) {\n                    let validMove = false;\n                    let packetLabel = \"\";\n                    let packetType = 'redirect';\n                    // Rule 1: User -> App (Starts flow)\n                    if (this.state === 'IDLE' && this.activeNode.id === 'user' && clickedNode.id === 'app') {\n                        validMove = true;\n                        // Start the chain\n                        this.connections.push({\n                            from: this.activeNode,\n                            to: clickedNode,\n                            progress: 0,\n                            type: 'redirect',\n                            label: 'Visit App'\n                        });\n                        this.activeNode = null;\n                        return; // Logic handled in handlePacketArrival now\n                    }\n                    // Rule 2: App -> API (Final Step)\n                    if (this.state === 'AUTHORIZED' && this.activeNode.id === 'app' && clickedNode.id === 'api') {\n                        validMove = true;\n                        packetLabel = \"Access Token\";\n                        packetType = 'access';\n                        this.state = 'ACCESSING';\n                    }\n                    if (validMove) {\n                        this.connections.push({\n                            from: this.activeNode,\n                            to: clickedNode,\n                            progress: 0,\n                            type: packetType,\n                            label: packetLabel\n                        });\n                    }\n                    this.activeNode = null;\n                } else {\n                    this.activeNode = null; // Cancel\n                }\n            }\n        } else {\n            this.activeNode = null;\n        }\n    }\n    onMouseMove(x, y) {\n        this.mousePos = {\n            x,\n            y\n        };\n    }\n    cleanup() {\n        this.nodes = [];\n        this.connections = [];\n    }\n    constructor(){\n        this.nodes = [];\n        this.connections = [];\n        this.activeNode = null;\n        this.mousePos = null;\n        this.time = 0;\n        this.state = 'IDLE';\n        this.message = \"Step 1: User visits the App to Log In\";\n        // Stars background\n        this.stars = [];\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9nYW1lL0F1dGhDb2RlQ29uc3RlbGxhdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7O0FBTU8sTUFBTUE7SUFZVEMsS0FBS0MsR0FBNkIsRUFBRUMsS0FBYSxFQUFFQyxNQUFjLEVBQUU7UUFDL0Qsd0JBQXdCO1FBQ3hCLCtEQUErRDtRQUMvRCxzQkFBc0I7UUFDdEIsdUJBQXVCO1FBQ3ZCLG9CQUFvQjtRQUNwQixzREFBc0Q7UUFDdEQsWUFBWTtRQUNaLDRDQUE0QztRQUM1Qyx1QkFBdUI7UUFFdkIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDVDtnQkFBRUMsR0FBR0gsUUFBUTtnQkFBS0ksR0FBR0gsU0FBUztnQkFBS0ksT0FBTztnQkFBY0MsSUFBSTtnQkFBT0MsUUFBUTtnQkFBSUMsTUFBTTtZQUFTO1lBQzlGO2dCQUFFTCxHQUFHSCxRQUFRO2dCQUFLSSxHQUFHSCxTQUFTO2dCQUFLSSxPQUFPO2dCQUFnQkMsSUFBSTtnQkFBUUMsUUFBUTtnQkFBSUMsTUFBTTtZQUFPO1lBQy9GO2dCQUFFTCxHQUFHSCxRQUFRO2dCQUFLSSxHQUFHSCxTQUFTO2dCQUFLSSxPQUFPO2dCQUFPQyxJQUFJO2dCQUFPQyxRQUFRO2dCQUFJQyxNQUFNO1lBQVc7WUFDekY7Z0JBQUVMLEdBQUdILFFBQVE7Z0JBQUtJLEdBQUdILFNBQVM7Z0JBQU1JLE9BQU87Z0JBQWtCQyxJQUFJO2dCQUFRQyxRQUFRO2dCQUFJQyxNQUFNO1lBQU87U0FDckc7UUFFRCxRQUFRO1FBQ1IsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLEtBQUtBLElBQUs7WUFDMUIsSUFBSSxDQUFDRCxLQUFLLENBQUNFLElBQUksQ0FBQztnQkFDWlIsR0FBR1MsS0FBS0MsTUFBTSxLQUFLYjtnQkFDbkJJLEdBQUdRLEtBQUtDLE1BQU0sS0FBS1o7Z0JBQ25CYSxNQUFNRixLQUFLQyxNQUFNLEtBQUs7Z0JBQ3RCRSxP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Q0FBQzFELFdBQVcsQ0FBQ1QsSUFBSSxDQUFDOzRCQUNsQnVCLE1BQU0sSUFBSSxDQUFDK0IsVUFBVTs0QkFDckJ2QyxJQUFJaUQ7NEJBQ0pwRCxVQUFVOzRCQUNWZixNQUFNd0U7NEJBQ04zRSxPQUFPMEU7d0JBQ1g7b0JBQ0o7b0JBQ0EsSUFBSSxDQUFDZCxVQUFVLEdBQUc7Z0JBQ3RCLE9BQU87b0JBQ0gsSUFBSSxDQUFDQSxVQUFVLEdBQUcsTUFBTSxTQUFTO2dCQUNyQztZQUNKO1FBQ0osT0FBTztZQUNILElBQUksQ0FBQ0EsVUFBVSxHQUFHO1FBQ3RCO0lBQ0o7SUFFQWdCLFlBQVk5RSxDQUFTLEVBQUVDLENBQVMsRUFBRTtRQUM5QixJQUFJLENBQUM4RCxRQUFRLEdBQUc7WUFBRS9EO1lBQUdDO1FBQUU7SUFDM0I7SUFFQThFLFVBQVU7UUFDTixJQUFJLENBQUNoRixLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUksQ0FBQ2tCLFdBQVcsR0FBRyxFQUFFO0lBQ3pCOzthQWhhUWxCLFFBQWlCLEVBQUU7YUFDbkJrQixjQUE0QixFQUFFO2FBQzlCNkMsYUFBMkI7YUFDM0JDLFdBQTRDO2FBQzVDaEQsT0FBZTthQUNmUyxRQUFtQjthQUNuQkMsVUFBa0I7UUFFMUIsbUJBQW1CO2FBQ1huQixRQUFpRSxFQUFFOztBQXdaL0UiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYW5uYV9pbmRpZ29jb25zdWx0aW5cXERvY3VtZW50c1xcR1BUR2FtZXNcXEF1dGhOZmxvd3NcXGxpYlxcZ2FtZVxcQXV0aENvZGVDb25zdGVsbGF0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdhbWVTY2VuZSB9IGZyb20gXCJAL2NvbXBvbmVudHMvZ2FtZS9HYW1lQ2FudmFzXCI7XHJcblxyXG50eXBlIFBvaW50ID0geyB4OiBudW1iZXIsIHk6IG51bWJlciwgbGFiZWw6IHN0cmluZywgaWQ6IHN0cmluZywgcmFkaXVzOiBudW1iZXIsIHR5cGU6ICd1c2VyJyB8ICdzZXJ2ZXInIHwgJ2F1dGgnIHwgJ3Jlc291cmNlJyB9O1xyXG50eXBlIENvbm5lY3Rpb24gPSB7IGZyb206IFBvaW50LCB0bzogUG9pbnQsIHByb2dyZXNzOiBudW1iZXIsIHR5cGU6ICdyZWRpcmVjdCcgfCAnY29kZScgfCAnZXhjaGFuZ2UnIHwgJ3Rva2VuJyB8ICdhY2Nlc3MnLCBsYWJlbDogc3RyaW5nIH07XHJcbnR5cGUgR2FtZVN0YXRlID0gJ0lETEUnIHwgJ1JFRElSRUNUSU5HJyB8ICdMT0dJTl9SRVFVSVJFRCcgfCAnUkVUVVJOSU5HX0NPREUnIHwgJ0VYQ0hBTkdJTkcnIHwgJ0FVVEhPUklaRUQnIHwgJ0FDQ0VTU0lORycgfCAnQ09NUExFVEUnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEF1dGhDb2RlQ29uc3RlbGxhdGlvbiBpbXBsZW1lbnRzIEdhbWVTY2VuZSB7XHJcbiAgICBwcml2YXRlIG5vZGVzOiBQb2ludFtdID0gW107XHJcbiAgICBwcml2YXRlIGNvbm5lY3Rpb25zOiBDb25uZWN0aW9uW10gPSBbXTtcclxuICAgIHByaXZhdGUgYWN0aXZlTm9kZTogUG9pbnQgfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgbW91c2VQb3M6IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSB0aW1lOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0ZTogR2FtZVN0YXRlID0gJ0lETEUnO1xyXG4gICAgcHJpdmF0ZSBtZXNzYWdlOiBzdHJpbmcgPSBcIlN0ZXAgMTogVXNlciB2aXNpdHMgdGhlIEFwcCB0byBMb2cgSW5cIjtcclxuXHJcbiAgICAvLyBTdGFycyBiYWNrZ3JvdW5kXHJcbiAgICBwcml2YXRlIHN0YXJzOiB7IHg6IG51bWJlciwgeTogbnVtYmVyLCBzaXplOiBudW1iZXIsIHNwZWVkOiBudW1iZXIgfVtdID0gW107XHJcblxyXG4gICAgaW5pdChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgICAvLyBMYXlvdXQ6IERpYW1vbmQgU2hhcGVcclxuICAgICAgICAvLyBVc2VyIChCb3R0b20pLCBBcHAgKExlZnQpLCBBdXRoIChUb3ApLCBBUEkgKFJpZ2h0KSAtIHJvdWdobHlcclxuICAgICAgICAvLyBBY3R1YWxseSwgY2xlYXJlcjogXHJcbiAgICAgICAgLy8gVXNlciAoQm90dG9tIENlbnRlcilcclxuICAgICAgICAvLyBBcHAgKExlZnQgQ2VudGVyKVxyXG4gICAgICAgIC8vIEF1dGggKFJpZ2h0IENlbnRlcikgLT4gTm8sIEF1dGggc2hvdWxkIGJlIGRpc3RpbmN0LlxyXG4gICAgICAgIC8vIExldCdzIGRvOlxyXG4gICAgICAgIC8vIEFwcCAoTGVmdCksIEF1dGggKFJpZ2h0KSwgQVBJIChGYXIgUmlnaHQpXHJcbiAgICAgICAgLy8gVXNlciAoQm90dG9tIENlbnRlcilcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtcclxuICAgICAgICAgICAgeyB4OiB3aWR0aCAqIDAuMiwgeTogaGVpZ2h0ICogMC41LCBsYWJlbDogXCJDbGllbnQgQXBwXCIsIGlkOiBcImFwcFwiLCByYWRpdXM6IDMwLCB0eXBlOiAnc2VydmVyJyB9LFxyXG4gICAgICAgICAgICB7IHg6IHdpZHRoICogMC41LCB5OiBoZWlnaHQgKiAwLjMsIGxhYmVsOiBcIkF1dGgwIFRlbmFudFwiLCBpZDogXCJhdXRoXCIsIHJhZGl1czogMzUsIHR5cGU6ICdhdXRoJyB9LFxyXG4gICAgICAgICAgICB7IHg6IHdpZHRoICogMC44LCB5OiBoZWlnaHQgKiAwLjUsIGxhYmVsOiBcIkFQSVwiLCBpZDogXCJhcGlcIiwgcmFkaXVzOiAzMCwgdHlwZTogJ3Jlc291cmNlJyB9LFxyXG4gICAgICAgICAgICB7IHg6IHdpZHRoICogMC41LCB5OiBoZWlnaHQgKiAwLjc1LCBsYWJlbDogXCJVc2VyIC8gQnJvd3NlclwiLCBpZDogXCJ1c2VyXCIsIHJhZGl1czogMjUsIHR5cGU6ICd1c2VyJyB9XHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgLy8gU3RhcnNcclxuICAgICAgICB0aGlzLnN0YXJzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgeDogTWF0aC5yYW5kb20oKSAqIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgeTogTWF0aC5yYW5kb20oKSAqIGhlaWdodCxcclxuICAgICAgICAgICAgICAgIHNpemU6IE1hdGgucmFuZG9tKCkgKiAyLFxyXG4gICAgICAgICAgICAgICAgc3BlZWQ6IE1hdGgucmFuZG9tKCkgKiAwLjUgKyAwLjFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkdDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy50aW1lICs9IGR0O1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ29uc3RlbGxhdGlvbihkdCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlQ29uc3RlbGxhdGlvbihkdDogbnVtYmVyKSB7XHJcbiAgICAgICAgLy8gU3RhdGUgTWFjaGluZSBMb2dpYyBmb3IgQ29ubmVjdGlvbnNcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jb25uZWN0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb25uID0gdGhpcy5jb25uZWN0aW9uc1tpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1vdmUgcGFja2V0XHJcbiAgICAgICAgICAgIGlmIChjb25uLnByb2dyZXNzIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgY29ubi5wcm9ncmVzcyArPSBkdCAqIDAuMztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFBhY2tldCBhcnJpdmVkXHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBhY2tldEFycml2YWwoY29ubik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnNwbGljZShpLCAxKTsgLy8gUmVtb3ZlIGNvbXBsZXRlZCBjb25uZWN0aW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlUGFja2V0QXJyaXZhbChjb25uOiBDb25uZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGNvbm4udHlwZSA9PT0gJ3JlZGlyZWN0JyAmJiBjb25uLnRvLmlkID09PSAnYXBwJykge1xyXG4gICAgICAgICAgICAvLyBVc2VyIHZpc2l0ZWQgQXBwLiBBcHAgcmVzcG9uZHMgd2l0aCAzMDIgUmVkaXJlY3QuXHJcbiAgICAgICAgICAgIC8vIFZpc3VhbCBlZmZlY3Q6IEFwcCBwdWxzZXNcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdSRURJUkVDVElORyc7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwiQXBwIHJlc3BvbmRzOiAnMzAyIEZvdW5kJy4gUmVkaXJlY3RpbmcgQnJvd3NlciB0byBBdXRoMC4uLlwiO1xyXG5cclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRoID0gdGhpcy5ub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gJ2F1dGgnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXIgPSB0aGlzLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSAndXNlcicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF1dGggJiYgdXNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHVzZXIsIC8vIEJyb3dzZXIgZm9sbG93cyByZWRpcmVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogYXV0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnQnJvd3NlciBSZWRpcmVjdCdcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgMTAwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbm4udHlwZSA9PT0gJ3JlZGlyZWN0JyAmJiBjb25uLnRvLmlkID09PSAnYXV0aCcpIHtcclxuICAgICAgICAgICAgLy8gVXNlciBhcnJpdmVkIGF0IEF1dGggU2VydmVyIChTdGVwIDEgQ29tcGxldGUpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnTE9HSU5fUkVRVUlSRUQnO1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlN0ZXAgMjogVXNlciBMb2dzIEluICYgR3JhbnRzIENvbnNlbnRcIjtcclxuXHJcbiAgICAgICAgICAgIC8vIEF1dG8tdHJpZ2dlciBcIkxvZ2luXCIgZWZmZWN0IHRoZW4gc2VuZCBjb2RlIGJhY2tcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRoID0gdGhpcy5ub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gJ2F1dGgnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXIgPSB0aGlzLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSAndXNlcicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF1dGggJiYgdXNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnUkVUVVJOSU5HX0NPREUnO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwiU3RlcCAzOiBBdXRoIFNlcnZlciByZWRpcmVjdHMgVXNlciBiYWNrIHdpdGggQ29kZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IGF1dGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB1c2VyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ0F1dGggQ29kZScgLy8gVmlzaWJsZSBDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDEwMDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb25uLnR5cGUgPT09ICdjb2RlJyAmJiBjb25uLnRvLmlkID09PSAndXNlcicpIHtcclxuICAgICAgICAgICAgLy8gVXNlciBoYXMgY29kZSwgbmVlZHMgdG8gZ2l2ZSB0byBBcHBcclxuICAgICAgICAgICAgY29uc3QgdXNlciA9IHRoaXMubm9kZXMuZmluZChuID0+IG4uaWQgPT09ICd1c2VyJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFwcCA9IHRoaXMubm9kZXMuZmluZChuID0+IG4uaWQgPT09ICdhcHAnKTtcclxuICAgICAgICAgICAgaWYgKHVzZXIgJiYgYXBwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHVzZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgdG86IGFwcCxcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogMCxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29kZScsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdBdXRoIENvZGUnXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb25uLnR5cGUgPT09ICdjb2RlJyAmJiBjb25uLnRvLmlkID09PSAnYXBwJykge1xyXG4gICAgICAgICAgICAvLyBBcHAgcmVjZWl2ZWQgY29kZS4gTm93IEJhY2stY2hhbm5lbCBleGNoYW5nZS5cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdFWENIQU5HSU5HJztcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJTdGVwIDQ6IEFwcCBleGNoYW5nZXMgQ29kZSBmb3IgVG9rZW4gKEJhY2stY2hhbm5lbClcIjtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcHAgPSB0aGlzLm5vZGVzLmZpbmQobiA9PiBuLmlkID09PSAnYXBwJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRoID0gdGhpcy5ub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gJ2F1dGgnKTtcclxuICAgICAgICAgICAgICAgIGlmIChhcHAgJiYgYXV0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IGFwcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IGF1dGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXhjaGFuZ2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ0NvZGUgKyBTZWNyZXQnXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDUwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbm4udHlwZSA9PT0gJ2V4Y2hhbmdlJyAmJiBjb25uLnRvLmlkID09PSAnYXV0aCcpIHtcclxuICAgICAgICAgICAgLy8gQXV0aCByZWNlaXZlZCB2YWxpZCBjb2RlICsgc2VjcmV0LiBSZXR1cm4gVG9rZW4uXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXBwID0gdGhpcy5ub2Rlcy5maW5kKG4gPT4gbi5pZCA9PT0gJ2FwcCcpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXV0aCA9IHRoaXMubm9kZXMuZmluZChuID0+IG4uaWQgPT09ICdhdXRoJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwICYmIGF1dGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBhdXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Rva2VuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdBY2Nlc3MgVG9rZW4nXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDUwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbm4udHlwZSA9PT0gJ3Rva2VuJyAmJiBjb25uLnRvLmlkID09PSAnYXBwJykge1xyXG4gICAgICAgICAgICAvLyBBcHAgaGFzIHRva2VuIVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ0FVVEhPUklaRUQnO1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlN0ZXAgNTogQXBwIHVzZXMgVG9rZW4gdG8gYWNjZXNzIEFQSVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb25uLnR5cGUgPT09ICdhY2Nlc3MnICYmIGNvbm4udG8uaWQgPT09ICdhcGknKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnQ09NUExFVEUnO1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkZsb3cgQ29tcGxldGUhIFNlY3VyZSBVc2VyIEFjY2VzcyBHcmFudGVkLlwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuZHJhd0NvbnN0ZWxsYXRpb24oY3R4KTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3Q29uc3RlbGxhdGlvbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICAgIC8vIEJhY2tncm91bmQgU3RhcnNcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOClcIjtcclxuICAgICAgICB0aGlzLnN0YXJzLmZvckVhY2goc3RhciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wYWNpdHkgPSAwLjUgKyBNYXRoLnNpbih0aGlzLnRpbWUgKiBzdGFyLnNwZWVkKSAqIDAuNTtcclxuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHN0YXIueCwgc3Rhci55LCBzdGFyLnNpemUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XHJcblxyXG4gICAgICAgIC8vIERyYXcgRnJvbnQtRW5kIC8gQmFjay1FbmQgWm9uZXNcclxuICAgICAgICBjb25zdCB6b25lWSA9IGN0eC5jYW52YXMuaGVpZ2h0ICogMC42NTtcclxuXHJcbiAgICAgICAgLy8gU2VwYXJhdG9yIExpbmVcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4Lm1vdmVUbygwLCB6b25lWSk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyhjdHguY2FudmFzLndpZHRoLCB6b25lWSk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMilcIjtcclxuICAgICAgICBjdHguc2V0TGluZURhc2goWzEwLCAxMF0pO1xyXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICBjdHguc2V0TGluZURhc2goW10pOyAvLyBSZXNldFxyXG5cclxuICAgICAgICAvLyBab25lIExhYmVsc1xyXG4gICAgICAgIGN0eC5mb250ID0gXCJib2xkIDE0cHggSW50ZXJcIjtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMylcIjtcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiQkFDSy1FTkQgKFRydXN0ZWQgWm9uZSlcIiwgMjAsIHpvbmVZIC0gMTUpO1xyXG4gICAgICAgIGN0eC5maWxsVGV4dChcIkZST05ULUVORCAoVW50cnVzdGVkIFpvbmUpXCIsIDIwLCB6b25lWSArIDI1KTtcclxuXHJcblxyXG4gICAgICAgIC8vIERyYXcgU3RhdGUvTWVzc2FnZVxyXG4gICAgICAgIGN0eC5mb250ID0gXCJib2xkIDI0cHggSW50ZXIsIHNhbnMtc2VyaWZcIjtcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdDT01QTEVURScpIGN0eC5maWxsU3R5bGUgPSBcIiM0YWRlODBcIjtcclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnQVVUSE9SSVpFRCcpIGN0eC5maWxsU3R5bGUgPSBcIiNmYWNjMTVcIjtcclxuICAgICAgICBlbHNlIGN0eC5maWxsU3R5bGUgPSBcIiNlODc5ZjlcIjtcclxuXHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMubWVzc2FnZSwgY3R4LmNhbnZhcy53aWR0aCAvIDIsIDE1MCk7XHJcblxyXG4gICAgICAgIC8vIENvbm5lY3Rpb25zICYgUGFja2V0c1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMuZm9yRWFjaChjb25uID0+IHtcclxuICAgICAgICAgICAgLy8gRHJhdyBMaW5lXHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhjb25uLmZyb20ueCwgY29ubi5mcm9tLnkpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKGNvbm4udG8ueCwgY29ubi50by55KTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMilcIjtcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERyYXcgUGFja2V0XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRYID0gY29ubi5mcm9tLnggKyAoY29ubi50by54IC0gY29ubi5mcm9tLngpICogY29ubi5wcm9ncmVzcztcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFkgPSBjb25uLmZyb20ueSArIChjb25uLnRvLnkgLSBjb25uLmZyb20ueSkgKiBjb25uLnByb2dyZXNzO1xyXG5cclxuICAgICAgICAgICAgLy8gUGFja2V0IENvbG9yXHJcbiAgICAgICAgICAgIGxldCBnbG93Q29sb3IgPSBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMSlcIjtcclxuICAgICAgICAgICAgaWYgKGNvbm4udHlwZSA9PT0gJ2NvZGUnKSBnbG93Q29sb3IgPSBcInJnYmEoMTY4LCA4NSwgMjQ3LCAxKVwiOyAvLyBQdXJwbGVcclxuICAgICAgICAgICAgaWYgKGNvbm4udHlwZSA9PT0gJ3Rva2VuJykgZ2xvd0NvbG9yID0gXCJyZ2JhKDI1MCwgMjA0LCAyMSwgMSlcIjsgLy8gWWVsbG93XHJcblxyXG4gICAgICAgICAgICAvLyBQYWNrZXQgR2xvd1xyXG4gICAgICAgICAgICBjb25zdCBnbG93ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGN1cnJlbnRYLCBjdXJyZW50WSwgNSwgY3VycmVudFgsIGN1cnJlbnRZLCAyMCk7XHJcbiAgICAgICAgICAgIGdsb3cuYWRkQ29sb3JTdG9wKDAsIGdsb3dDb2xvcik7XHJcbiAgICAgICAgICAgIGdsb3cuYWRkQ29sb3JTdG9wKDEsIFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwKVwiKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdsb3c7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyhjdXJyZW50WCwgY3VycmVudFksIDIwLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBQYWNrZXQgTGFiZWxcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZmZmZlwiO1xyXG4gICAgICAgICAgICBjdHguZm9udCA9IFwiMTJweCBJbnRlclwiO1xyXG4gICAgICAgICAgICBjdHguZmlsbFRleHQoY29ubi5sYWJlbCwgY3VycmVudFgsIGN1cnJlbnRZIC0gMjApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBEcmF3IERyYWcgTGluZVxyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZU5vZGUgJiYgdGhpcy5tb3VzZVBvcykge1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy5hY3RpdmVOb2RlLngsIHRoaXMuYWN0aXZlTm9kZS55KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLm1vdXNlUG9zLngsIHRoaXMubW91c2VQb3MueSk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiI2ZmZmZmZlwiO1xyXG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2goWzUsIDVdKTtcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vZGVzXHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAvLyBOb2RlIENpcmNsZVxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMobm9kZS54LCBub2RlLnksIG5vZGUucmFkaXVzLCAwLCBNYXRoLlBJICogMik7XHJcblxyXG4gICAgICAgICAgICAvLyBEeW5hbWljIG5vZGUgY29sb3JpbmdcclxuICAgICAgICAgICAgbGV0IGNvbG9yID0gXCIjMzM0MTU1XCI7XHJcbiAgICAgICAgICAgIGxldCBnbG93Q29sb3IgPSBcInJnYmEoMTQ4LCAxNjMsIDE4NCwgMC41KVwiO1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwIFB1bHNlIG9uIFJlZGlyZWN0XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnUkVESVJFQ1RJTkcnICYmIG5vZGUuaWQgPT09ICdhcHAnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWQgUHVsc2VcclxuICAgICAgICAgICAgICAgIGdsb3dDb2xvciA9IFwicmdiYSgyMzksIDY4LCA2OCwgMC44KVwiO1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBcIiNlZjQ0NDRcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3VzZXInKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IFwiI2E4NTVmN1wiO1xyXG4gICAgICAgICAgICAgICAgZ2xvd0NvbG9yID0gXCJyZ2JhKDE2OCwgODUsIDI0NywgMC41KVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdhdXRoJykge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBcIiNmNTllMGJcIjtcclxuICAgICAgICAgICAgICAgIGdsb3dDb2xvciA9IFwicmdiYSgyNDUsIDE1OCwgMTEsIDAuNSlcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnc2VydmVyJykge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBcIiMzYjgyZjZcIjtcclxuICAgICAgICAgICAgICAgIGdsb3dDb2xvciA9IFwicmdiYSg1OSwgMTMwLCAyNDYsIDAuNSlcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gR2xvdyBhbmltYXRpb25cclxuICAgICAgICAgICAgY29uc3QgZ2xvd1NpemUgPSAxMCArIE1hdGguc2luKHRoaXMudGltZSAqIDMpICogNTtcclxuICAgICAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQobm9kZS54LCBub2RlLnksIG5vZGUucmFkaXVzLCBub2RlLngsIG5vZGUueSwgbm9kZS5yYWRpdXMgKyBnbG93U2l6ZSk7XHJcbiAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBnbG93Q29sb3IpO1xyXG4gICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCJyZ2JhKDAsMCwwLDApXCIpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcblxyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmFyYyhub2RlLngsIG5vZGUueSwgbm9kZS5yYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJvcmRlclxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBMYWJlbFxyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjY2JkNWUxXCI7XHJcbiAgICAgICAgICAgIGN0eC5mb250ID0gXCIxNHB4IEludGVyXCI7XHJcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChub2RlLmxhYmVsLCBub2RlLngsIG5vZGUueSArIG5vZGUucmFkaXVzICsgMjApO1xyXG5cclxuICAgICAgICAgICAgLy8gSW5pdGlhbHNcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgICAgICAgICAgY3R4LmZvbnQgPSBcImJvbGQgMTJweCBJbnRlclwiO1xyXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsID0gbm9kZS5sYWJlbC5zdWJzdHJpbmcoMCwgMik7XHJcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChpbml0aWFsLCBub2RlLngsIG5vZGUueSk7XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IFwiMzAyXCIgVGV4dCBpZiBSZWRpcmVjdGluZ1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ1JFRElSRUNUSU5HJyAmJiBub2RlLmlkID09PSAnYXBwJykge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2VmNDQ0NFwiO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBcImJvbGQgMTZweCBJbnRlclwiO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiMzAyIEZvdW5kXCIsIG5vZGUueCwgbm9kZS55IC0gNDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEluc3RydWN0aW9uc1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiM2NDc0OGJcIjtcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgY3R4LmZvbnQgPSBcIjE0cHggSW50ZXJcIjtcclxuICAgICAgICBjdHguZmlsbFRleHQoXCJJbnN0cnVjdGlvbnM6IERyYWcgZnJvbSBVc2VyIHRvIEFwcCB0byBzdGFydC5cIiwgMjAsIGN0eC5jYW52YXMuaGVpZ2h0IC0gMzApO1xyXG4gICAgfVxyXG5cclxuICAgIG9uQ2xpY2soeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ0lETEUnICYmIHRoaXMuc3RhdGUgIT09ICdBVVRIT1JJWkVEJykgcmV0dXJuOyAvLyBPbmx5IGFsbG93IGludGVyYXRpb25zIGF0IHNwZWNpZmljIHBvaW50c1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnQ09NUExFVEUnKSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IGNsaWNrZWROb2RlID0gdGhpcy5ub2Rlcy5maW5kKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkeCA9IG5vZGUueCAtIHg7XHJcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gbm9kZS55IC0geTtcclxuICAgICAgICAgICAgcmV0dXJuIChkeCAqIGR4ICsgZHkgKiBkeSkgPCAobm9kZS5yYWRpdXMgKiAyICogbm9kZS5yYWRpdXMgKiAyKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGNsaWNrZWROb2RlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTVEFSVCBEUkFHXHJcbiAgICAgICAgICAgICAgICAvLyBSdWxlIDE6IElETEUgLT4gU3RhcnQgYXQgVXNlciAoc2ltdWxhdGluZyB1c2VyIGNsaWNraW5nIFwiTG9naW5cIilcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnSURMRScgJiYgY2xpY2tlZE5vZGUuaWQgPT09ICd1c2VyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZSA9IGNsaWNrZWROb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUnVsZSAyOiBBVVRIT1JJWkVEIC0+IFN0YXJ0IGF0IEFwcFxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ0FVVEhPUklaRUQnICYmIGNsaWNrZWROb2RlLmlkID09PSAnYXBwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZSA9IGNsaWNrZWROb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRU5EIERSQUdcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZU5vZGUgIT09IGNsaWNrZWROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbGlkTW92ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYWNrZXRMYWJlbCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhY2tldFR5cGU6IENvbm5lY3Rpb25bJ3R5cGUnXSA9ICdyZWRpcmVjdCc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1bGUgMTogVXNlciAtPiBBcHAgKFN0YXJ0cyBmbG93KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnSURMRScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlLmlkID09PSAndXNlcicgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2tlZE5vZGUuaWQgPT09ICdhcHAnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZE1vdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCB0aGUgY2hhaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHRoaXMuYWN0aXZlTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBjbGlja2VkTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnVmlzaXQgQXBwJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gTG9naWMgaGFuZGxlZCBpbiBoYW5kbGVQYWNrZXRBcnJpdmFsIG5vd1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVsZSAyOiBBcHAgLT4gQVBJIChGaW5hbCBTdGVwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnQVVUSE9SSVpFRCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlLmlkID09PSAnYXBwJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlja2VkTm9kZS5pZCA9PT0gJ2FwaScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRNb3ZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0TGFiZWwgPSBcIkFjY2VzcyBUb2tlblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRUeXBlID0gJ2FjY2Vzcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnQUNDRVNTSU5HJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZE1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHRoaXMuYWN0aXZlTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBjbGlja2VkTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcGFja2V0VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBwYWNrZXRMYWJlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlID0gbnVsbDsgLy8gQ2FuY2VsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU5vZGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbk1vdXNlTW92ZSh4OiBudW1iZXIsIHk6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMubW91c2VQb3MgPSB7IHgsIHkgfTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhbnVwKCkge1xyXG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zID0gW107XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbIkF1dGhDb2RlQ29uc3RlbGxhdGlvbiIsImluaXQiLCJjdHgiLCJ3aWR0aCIsImhlaWdodCIsIm5vZGVzIiwieCIsInkiLCJsYWJlbCIsImlkIiwicmFkaXVzIiwidHlwZSIsInN0YXJzIiwiaSIsInB1c2giLCJNYXRoIiwicmFuZG9tIiwic2l6ZSIsInNwZWVkIiwidXBkYXRlIiwiZHQiLCJ0aW1lIiwidXBkYXRlQ29uc3RlbGxhdGlvbiIsImNvbm5lY3Rpb25zIiwibGVuZ3RoIiwiY29ubiIsInByb2dyZXNzIiwiaGFuZGxlUGFja2V0QXJyaXZhbCIsInNwbGljZSIsInRvIiwic3RhdGUiLCJtZXNzYWdlIiwic2V0VGltZW91dCIsImF1dGgiLCJmaW5kIiwibiIsInVzZXIiLCJmcm9tIiwiYXBwIiwiZHJhdyIsImRyYXdDb25zdGVsbGF0aW9uIiwiZmlsbFN0eWxlIiwiZm9yRWFjaCIsInN0YXIiLCJvcGFjaXR5Iiwic2luIiwiZ2xvYmFsQWxwaGEiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGwiLCJ6b25lWSIsImNhbnZhcyIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZVN0eWxlIiwic2V0TGluZURhc2giLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJmb250IiwidGV4dEFsaWduIiwiZmlsbFRleHQiLCJjdXJyZW50WCIsImN1cnJlbnRZIiwiZ2xvd0NvbG9yIiwiZ2xvdyIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiYWRkQ29sb3JTdG9wIiwiYWN0aXZlTm9kZSIsIm1vdXNlUG9zIiwidGV4dEJhc2VsaW5lIiwibm9kZSIsImNvbG9yIiwiZ2xvd1NpemUiLCJncmFkaWVudCIsImluaXRpYWwiLCJzdWJzdHJpbmciLCJvbkNsaWNrIiwiY2xpY2tlZE5vZGUiLCJkeCIsImR5IiwidmFsaWRNb3ZlIiwicGFja2V0TGFiZWwiLCJwYWNrZXRUeXBlIiwib25Nb3VzZU1vdmUiLCJjbGVhbnVwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/game/AuthCodeConstellation.ts\n"));

/***/ })

});
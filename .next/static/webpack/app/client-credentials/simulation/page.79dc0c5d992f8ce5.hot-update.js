"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/client-credentials/simulation/page",{

/***/ "(app-pages-browser)/./lib/game/ClientCredentialsConstellation.ts":
/*!****************************************************!*\
  !*** ./lib/game/ClientCredentialsConstellation.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientCredentialsConstellation: () => (/* binding */ ClientCredentialsConstellation)\n/* harmony export */ });\nclass ClientCredentialsConstellation {\n    init(ctx, width, height) {\n        this.nodes = [\n            {\n                x: width * 0.2,\n                y: height * 0.6,\n                label: \"M2M App\",\n                id: \"app\",\n                radius: 25\n            },\n            {\n                x: width * 0.5,\n                y: height * 0.3,\n                label: \"Auth0 Tenant\",\n                id: \"tenant\",\n                radius: 30\n            },\n            {\n                x: width * 0.8,\n                y: height * 0.6,\n                label: \"API\",\n                id: \"api\",\n                radius: 25\n            }\n        ];\n        // Stars\n        this.stars = [];\n        for(let i = 0; i < 100; i++){\n            this.stars.push({\n                x: Math.random() * width,\n                y: Math.random() * height,\n                size: Math.random() * 2,\n                speed: Math.random() * 0.5 + 0.1\n            });\n        }\n    }\n    update(dt) {\n        this.time += dt;\n        this.updateConstellation(dt);\n    }\n    updateConstellation(dt) {\n        // State Machine Logic for Connections\n        for(let i = this.connections.length - 1; i >= 0; i--){\n            const conn = this.connections[i];\n            // Move packet\n            // Slower speed for better readability (0.8 -> 0.3)\n            if (conn.progress < 1) {\n                conn.progress += dt * 0.3;\n            } else {\n                // Packet arrived\n                this.handlePacketArrival(conn);\n                this.connections.splice(i, 1); // Remove completed connection\n            }\n        }\n    }\n    handlePacketArrival(conn) {\n        if (conn.type === 'request' && conn.to.id === 'tenant') {\n            // Step 1 Complete: Tenant received credentials\n            this.state = 'ISSUING';\n            this.message = \"Step 2: Tenant validates and issues Access Token\";\n            // Auto-send response back to app\n            setTimeout(()=>{\n                const app = this.nodes.find((n)=>n.id === 'app');\n                const tenant = this.nodes.find((n)=>n.id === 'tenant');\n                if (app && tenant) {\n                    this.connections.push({\n                        from: tenant,\n                        to: app,\n                        progress: 0,\n                        type: 'response',\n                        label: 'Access Token'\n                    });\n                }\n            }, 500);\n        } else if (conn.type === 'response' && conn.to.id === 'app') {\n            // Step 2 Complete: App received token\n            this.state = 'AUTHORIZED';\n            this.message = \"Step 3: Connect App to API to use the Token\";\n        } else if (conn.type === 'access' && conn.to.id === 'api') {\n            // Step 3 Complete: API received token\n            this.state = 'COMPLETE';\n            this.message = \"Flow Complete! Resource Accessed Successfully.\";\n        }\n    }\n    draw(ctx, width, height) {\n        this.drawConstellation(ctx);\n    }\n    drawConstellation(ctx) {\n        // Background Stars\n        ctx.fillStyle = \"rgba(255, 255, 255, 0.8)\";\n        this.stars.forEach((star)=>{\n            const opacity = 0.5 + Math.sin(this.time * star.speed) * 0.5;\n            ctx.globalAlpha = opacity;\n            ctx.beginPath();\n            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n            ctx.fill();\n        });\n        ctx.globalAlpha = 1.0;\n        // Draw State/Message (Top Center)\n        ctx.font = \"bold 24px Inter, sans-serif\";\n        ctx.textAlign = \"center\";\n        // Dynamic color based on state\n        if (this.state === 'COMPLETE') ctx.fillStyle = \"#4ade80\"; // Green\n        else if (this.state === 'AUTHORIZED') ctx.fillStyle = \"#facc15\"; // Yellow\n        else ctx.fillStyle = \"#60a5fa\"; // Blue\n        ctx.fillText(this.message, ctx.canvas.width / 2, 150);\n        // Connections & Packets\n        this.connections.forEach((conn)=>{\n            // Draw Line\n            ctx.beginPath();\n            ctx.moveTo(conn.from.x, conn.from.y);\n            ctx.lineTo(conn.to.x, conn.to.y);\n            ctx.strokeStyle = \"rgba(255, 255, 255, 0.2)\";\n            ctx.lineWidth = 2;\n            ctx.stroke();\n            // Draw Packet\n            const currentX = conn.from.x + (conn.to.x - conn.from.x) * conn.progress;\n            const currentY = conn.from.y + (conn.to.y - conn.from.y) * conn.progress;\n            // Packet Glow\n            const glow = ctx.createRadialGradient(currentX, currentY, 5, currentX, currentY, 20);\n            glow.addColorStop(0, \"rgba(255, 255, 255, 1)\");\n            glow.addColorStop(1, \"rgba(255, 255, 255, 0)\");\n            ctx.fillStyle = glow;\n            ctx.beginPath();\n            ctx.arc(currentX, currentY, 20, 0, Math.PI * 2);\n            ctx.fill();\n            // Packet Label\n            ctx.fillStyle = \"#ffffff\";\n            ctx.font = \"12px Inter\";\n            ctx.fillText(conn.label, currentX, currentY - 20);\n        });\n        // Draw Drag Line\n        if (this.activeNode && this.mousePos) {\n            ctx.beginPath();\n            ctx.moveTo(this.activeNode.x, this.activeNode.y);\n            ctx.lineTo(this.mousePos.x, this.mousePos.y);\n            ctx.strokeStyle = \"#ffffff\";\n            ctx.setLineDash([\n                5,\n                5\n            ]);\n            ctx.lineWidth = 2;\n            ctx.stroke();\n            ctx.setLineDash([]);\n        }\n        // Nodes\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        this.nodes.forEach((node)=>{\n            // Node Circle\n            ctx.beginPath();\n            ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);\n            // Dynamic node coloring\n            let color = \"#334155\"; // Default Slate\n            let glowColor = \"rgba(59, 130, 246, 0.5)\"; // Blue\n            // Highlight source node for current step\n            if (this.state === 'IDLE' && node.id === 'app') {\n                color = \"#3b82f6\"; // Blue\n                glowColor = \"rgba(59, 130, 246, 0.8)\";\n            } else if (this.state === 'AUTHORIZED' && node.id === 'app') {\n                color = \"#f59e0b\"; // Amber (has token)\n                glowColor = \"rgba(245, 158, 11, 0.8)\";\n            } else if (node.id === 'api' && this.state === 'COMPLETE') {\n                color = \"#22c55e\"; // Green\n                glowColor = \"rgba(34, 197, 94, 0.8)\";\n            }\n            // Glow animation\n            const glowSize = 10 + Math.sin(this.time * 3) * 5;\n            const gradient = ctx.createRadialGradient(node.x, node.y, node.radius, node.x, node.y, node.radius + glowSize);\n            gradient.addColorStop(0, glowColor);\n            gradient.addColorStop(1, \"rgba(0,0,0,0)\");\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.fillStyle = color;\n            ctx.beginPath();\n            ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);\n            ctx.fill();\n            // Border\n            ctx.strokeStyle = \"white\";\n            ctx.lineWidth = 2;\n            ctx.stroke();\n            // Label\n            ctx.fillStyle = \"#cbd5e1\";\n            ctx.font = \"14px Inter\";\n            ctx.fillText(node.label, node.x, node.y + node.radius + 20);\n            // Icon/Text inside node\n            ctx.fillStyle = \"white\";\n            ctx.font = \"bold 12px Inter\";\n            // Simple Initials\n            const initial = node.label.split(' ').map((w)=>w[0]).join('');\n            ctx.fillText(initial, node.x, node.y);\n        });\n        // Instructions (Moved to Bottom Left, smaller)\n        ctx.fillStyle = \"#64748b\";\n        ctx.textAlign = \"left\";\n        ctx.font = \"14px Inter\";\n        ctx.fillText(\"Instructions: Click and drag to connect nodes.\", 20, ctx.canvas.height - 30);\n    }\n    onClick(x, y) {\n        // Prevent interaction if animating\n        if (this.state === 'REQUESTING' || this.state === 'ISSUING') return;\n        if (this.state === 'COMPLETE') return;\n        const clickedNode = this.nodes.find((node)=>{\n            const dx = node.x - x;\n            const dy = node.y - y;\n            return dx * dx + dy * dy < node.radius * 2 * node.radius * 2;\n        });\n        if (clickedNode) {\n            if (!this.activeNode) {\n                // START DRAG\n                // Enforce Start Node based on State\n                if (this.state === 'IDLE' && clickedNode.id === 'app') {\n                    this.activeNode = clickedNode;\n                } else if (this.state === 'AUTHORIZED' && clickedNode.id === 'app') {\n                    this.activeNode = clickedNode;\n                }\n            } else {\n                // END DRAG\n                if (this.activeNode !== clickedNode) {\n                    // Check Logic\n                    let validMove = false;\n                    let packetLabel = \"\";\n                    let packetType = 'request';\n                    // Rule 1: Idle -> Connect App to Tenant\n                    if (this.state === 'IDLE' && this.activeNode.id === 'app' && clickedNode.id === 'tenant') {\n                        validMove = true;\n                        packetLabel = \"ID + Secret\";\n                        packetType = 'request';\n                        this.state = 'REQUESTING';\n                    }\n                    // Rule 2: Authorized -> Connect App to API\n                    if (this.state === 'AUTHORIZED' && this.activeNode.id === 'app' && clickedNode.id === 'api') {\n                        validMove = true;\n                        packetLabel = \"Access Token\";\n                        packetType = 'access';\n                        this.state = 'ACCESSING';\n                    }\n                    if (validMove) {\n                        this.connections.push({\n                            from: this.activeNode,\n                            to: clickedNode,\n                            progress: 0,\n                            type: packetType,\n                            label: packetLabel\n                        });\n                    }\n                    this.activeNode = null;\n                } else {\n                    this.activeNode = null; // Cancel\n                }\n            }\n        } else {\n            this.activeNode = null; // Click empty space to cancel\n        }\n    }\n    onMouseMove(x, y) {\n        this.mousePos = {\n            x,\n            y\n        };\n    }\n    cleanup() {\n        this.nodes = [];\n        this.stars = [];\n    }\n    constructor(){\n        this.nodes = [];\n        this.connections = [];\n        this.activeNode = null;\n        this.mousePos = null;\n        this.time = 0;\n        this.state = 'IDLE';\n        this.message = \"Step 1: Connect App to Tenant to send Credentials\";\n        // Stars background\n        this.stars = [];\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9nYW1lL0NsaWVudENyZWRlbnRpYWxzQ29uc3RlbGxhdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7O0FBTU8sTUFBTUE7SUFZVEMsS0FBS0MsR0FBNkIsRUFBRUMsS0FBYSxFQUFFQyxNQUFjLEVBQUU7UUFDL0QsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDVDtnQkFBRUMsR0FBR0gsUUFBUTtnQkFBS0ksR0FBR0gsU0FBUztnQkFBS0ksT0FBTztnQkFBV0MsSUFBSTtnQkFBT0MsUUFBUTtZQUFHO1lBQzNFO2dCQUFFSixHQUFHSCxRQUFRO2dCQUFLSSxHQUFHSCxTQUFTO2dCQUFLSSxPQUFPO2dCQUFnQkMsSUFBSTtnQkFBVUMsUUFBUTtZQUFHO1lBQ25GO2dCQUFFSixHQUFHSCxRQUFRO2dCQUFLSSxHQUFHSCxTQUFTO2dCQUFLSSxPQUFPO2dCQUFPQyxJQUFJO2dCQUFPQyxRQUFRO1lBQUc7U0FDMUU7UUFFRCxRQUFRO1FBQ1IsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLEtBQUtBLElBQUs7WUFDMUIsSUFBSSxDQUFDRCxLQUFLLENBQUNFLElBQUksQ0FBQztnQkFDWlAsR0FBR1EsS0FBS0MsTUFBTSxLQUFLWjtnQkFDbkJJLEdBQUdPLEtBQUtDLE1BQU0sS0FBS1g7Z0JBQ25CWSxNQUFNRixLQUFLQyxNQUFNLEtBQUs7Z0JBQ3RCRSxPQUFPSCxLQUFLQyxNQUFNLEtBQUssTUFBTTtZQUNqQztRQUNKO0lBQ0o7SUFFQUcsT0FBT0MsRUFBVSxFQUFFO1FBQ2YsSUFBSSxDQUFDQyxJQUFJLElBQUlEO1FBQ2IsSUFBSSxDQUFDRSxtQkFBbUIsQ0FBQ0Y7SUFDN0I7SUFFQUUsb0JBQW9CRixFQUFVLEVBQUU7UUFDNUIsc0NBQXNDO1FBQ3RDLElBQUssSUFBSVAsSUFBSSxJQUFJLENBQUNVLFdBQVcsQ0FBQ0MsTUFBTSxHQUFHLEdBQUdYLEtBQUssR0FBR0EsSUFB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QUFPMkU7d0JBQ1g7b0JBQ0o7b0JBQ0EsSUFBSSxDQUFDbkIsVUFBVSxHQUFHO2dCQUN0QixPQUFPO29CQUNILElBQUksQ0FBQ0EsVUFBVSxHQUFHLE1BQU0sU0FBUztnQkFDckM7WUFDSjtRQUNKLE9BQU87WUFDSCxJQUFJLENBQUNBLFVBQVUsR0FBRyxNQUFNLDhCQUE4QjtRQUMxRDtJQUNKO0lBRUFxQixZQUFZL0UsQ0FBUyxFQUFFQyxDQUFTLEVBQUU7UUFDOUIsSUFBSSxDQUFDMEQsUUFBUSxHQUFHO1lBQUUzRDtZQUFHQztRQUFFO0lBQzNCO0lBRUErRSxVQUFVO1FBQ04sSUFBSSxDQUFDakYsS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUNNLEtBQUssR0FBRyxFQUFFO0lBQ25COzthQWhTUU4sUUFBaUIsRUFBRTthQUNuQmlCLGNBQTRCLEVBQUU7YUFDOUIwQyxhQUEyQjthQUMzQkMsV0FBNEM7YUFDNUM3QyxPQUFlO2FBQ2ZVLFFBQW1CO2FBQ25CQyxVQUFrQjtRQUUxQixtQkFBbUI7YUFDWHBCLFFBQWlFLEVBQUU7O0FBd1IvRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhbm5hX2luZGlnb2NvbnN1bHRpblxcRG9jdW1lbnRzXFxHUFRHYW1lc1xcQXV0aE5mbG93c1xcbGliXFxnYW1lXFxDbGllbnRDcmVkZW50aWFsc0NvbnN0ZWxsYXRpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR2FtZVNjZW5lIH0gZnJvbSBcIkAvY29tcG9uZW50cy9nYW1lL0dhbWVDYW52YXNcIjtcclxuXHJcbnR5cGUgUG9pbnQgPSB7IHg6IG51bWJlciwgeTogbnVtYmVyLCBsYWJlbDogc3RyaW5nLCBpZDogc3RyaW5nLCByYWRpdXM6IG51bWJlciB9O1xyXG50eXBlIENvbm5lY3Rpb24gPSB7IGZyb206IFBvaW50LCB0bzogUG9pbnQsIHByb2dyZXNzOiBudW1iZXIsIHR5cGU6ICdyZXF1ZXN0JyB8ICdyZXNwb25zZScgfCAnYWNjZXNzJywgbGFiZWw6IHN0cmluZyB9O1xyXG50eXBlIEdhbWVTdGF0ZSA9ICdJRExFJyB8ICdSRVFVRVNUSU5HJyB8ICdJU1NVSU5HJyB8ICdBVVRIT1JJWkVEJyB8ICdBQ0NFU1NJTkcnIHwgJ0NPTVBMRVRFJztcclxuXHJcbmV4cG9ydCBjbGFzcyBDbGllbnRDcmVkZW50aWFsc0NvbnN0ZWxsYXRpb24gaW1wbGVtZW50cyBHYW1lU2NlbmUge1xyXG4gICAgcHJpdmF0ZSBub2RlczogUG9pbnRbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBjb25uZWN0aW9uczogQ29ubmVjdGlvbltdID0gW107XHJcbiAgICBwcml2YXRlIGFjdGl2ZU5vZGU6IFBvaW50IHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIG1vdXNlUG9zOiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH0gfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgdGltZTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGU6IEdhbWVTdGF0ZSA9ICdJRExFJztcclxuICAgIHByaXZhdGUgbWVzc2FnZTogc3RyaW5nID0gXCJTdGVwIDE6IENvbm5lY3QgQXBwIHRvIFRlbmFudCB0byBzZW5kIENyZWRlbnRpYWxzXCI7XHJcblxyXG4gICAgLy8gU3RhcnMgYmFja2dyb3VuZFxyXG4gICAgcHJpdmF0ZSBzdGFyczogeyB4OiBudW1iZXIsIHk6IG51bWJlciwgc2l6ZTogbnVtYmVyLCBzcGVlZDogbnVtYmVyIH1bXSA9IFtdO1xyXG5cclxuICAgIGluaXQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtcclxuICAgICAgICAgICAgeyB4OiB3aWR0aCAqIDAuMiwgeTogaGVpZ2h0ICogMC42LCBsYWJlbDogXCJNMk0gQXBwXCIsIGlkOiBcImFwcFwiLCByYWRpdXM6IDI1IH0sXHJcbiAgICAgICAgICAgIHsgeDogd2lkdGggKiAwLjUsIHk6IGhlaWdodCAqIDAuMywgbGFiZWw6IFwiQXV0aDAgVGVuYW50XCIsIGlkOiBcInRlbmFudFwiLCByYWRpdXM6IDMwIH0sXHJcbiAgICAgICAgICAgIHsgeDogd2lkdGggKiAwLjgsIHk6IGhlaWdodCAqIDAuNiwgbGFiZWw6IFwiQVBJXCIsIGlkOiBcImFwaVwiLCByYWRpdXM6IDI1IH1cclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAvLyBTdGFyc1xyXG4gICAgICAgIHRoaXMuc3RhcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB4OiBNYXRoLnJhbmRvbSgpICogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICB5OiBNYXRoLnJhbmRvbSgpICogaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogTWF0aC5yYW5kb20oKSAqIDIsXHJcbiAgICAgICAgICAgICAgICBzcGVlZDogTWF0aC5yYW5kb20oKSAqIDAuNSArIDAuMVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGR0OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLnRpbWUgKz0gZHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDb25zdGVsbGF0aW9uKGR0KTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVDb25zdGVsbGF0aW9uKGR0OiBudW1iZXIpIHtcclxuICAgICAgICAvLyBTdGF0ZSBNYWNoaW5lIExvZ2ljIGZvciBDb25uZWN0aW9uc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLmNvbm5lY3Rpb25zW2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gTW92ZSBwYWNrZXRcclxuICAgICAgICAgICAgLy8gU2xvd2VyIHNwZWVkIGZvciBiZXR0ZXIgcmVhZGFiaWxpdHkgKDAuOCAtPiAwLjMpXHJcbiAgICAgICAgICAgIGlmIChjb25uLnByb2dyZXNzIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgY29ubi5wcm9ncmVzcyArPSBkdCAqIDAuMztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFBhY2tldCBhcnJpdmVkXHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBhY2tldEFycml2YWwoY29ubik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnNwbGljZShpLCAxKTsgLy8gUmVtb3ZlIGNvbXBsZXRlZCBjb25uZWN0aW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlUGFja2V0QXJyaXZhbChjb25uOiBDb25uZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGNvbm4udHlwZSA9PT0gJ3JlcXVlc3QnICYmIGNvbm4udG8uaWQgPT09ICd0ZW5hbnQnKSB7XHJcbiAgICAgICAgICAgIC8vIFN0ZXAgMSBDb21wbGV0ZTogVGVuYW50IHJlY2VpdmVkIGNyZWRlbnRpYWxzXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnSVNTVUlORyc7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwiU3RlcCAyOiBUZW5hbnQgdmFsaWRhdGVzIGFuZCBpc3N1ZXMgQWNjZXNzIFRva2VuXCI7XHJcbiAgICAgICAgICAgIC8vIEF1dG8tc2VuZCByZXNwb25zZSBiYWNrIHRvIGFwcFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFwcCA9IHRoaXMubm9kZXMuZmluZChuID0+IG4uaWQgPT09ICdhcHAnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbmFudCA9IHRoaXMubm9kZXMuZmluZChuID0+IG4uaWQgPT09ICd0ZW5hbnQnKTtcclxuICAgICAgICAgICAgICAgIGlmIChhcHAgJiYgdGVuYW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdGVuYW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogYXBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Jlc3BvbnNlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdBY2Nlc3MgVG9rZW4nXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDUwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbm4udHlwZSA9PT0gJ3Jlc3BvbnNlJyAmJiBjb25uLnRvLmlkID09PSAnYXBwJykge1xyXG4gICAgICAgICAgICAvLyBTdGVwIDIgQ29tcGxldGU6IEFwcCByZWNlaXZlZCB0b2tlblxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ0FVVEhPUklaRUQnO1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlN0ZXAgMzogQ29ubmVjdCBBcHAgdG8gQVBJIHRvIHVzZSB0aGUgVG9rZW5cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29ubi50eXBlID09PSAnYWNjZXNzJyAmJiBjb25uLnRvLmlkID09PSAnYXBpJykge1xyXG4gICAgICAgICAgICAvLyBTdGVwIDMgQ29tcGxldGU6IEFQSSByZWNlaXZlZCB0b2tlblxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ0NPTVBMRVRFJztcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJGbG93IENvbXBsZXRlISBSZXNvdXJjZSBBY2Nlc3NlZCBTdWNjZXNzZnVsbHkuXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5kcmF3Q29uc3RlbGxhdGlvbihjdHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXdDb25zdGVsbGF0aW9uKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgICAgLy8gQmFja2dyb3VuZCBTdGFyc1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KVwiO1xyXG4gICAgICAgIHRoaXMuc3RhcnMuZm9yRWFjaChzdGFyID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3BhY2l0eSA9IDAuNSArIE1hdGguc2luKHRoaXMudGltZSAqIHN0YXIuc3BlZWQpICogMC41O1xyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoc3Rhci54LCBzdGFyLnksIHN0YXIuc2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEuMDtcclxuXHJcbiAgICAgICAgLy8gRHJhdyBTdGF0ZS9NZXNzYWdlIChUb3AgQ2VudGVyKVxyXG4gICAgICAgIGN0eC5mb250ID0gXCJib2xkIDI0cHggSW50ZXIsIHNhbnMtc2VyaWZcIjtcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuXHJcbiAgICAgICAgLy8gRHluYW1pYyBjb2xvciBiYXNlZCBvbiBzdGF0ZVxyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnQ09NUExFVEUnKSBjdHguZmlsbFN0eWxlID0gXCIjNGFkZTgwXCI7IC8vIEdyZWVuXHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ0FVVEhPUklaRUQnKSBjdHguZmlsbFN0eWxlID0gXCIjZmFjYzE1XCI7IC8vIFllbGxvd1xyXG4gICAgICAgIGVsc2UgY3R4LmZpbGxTdHlsZSA9IFwiIzYwYTVmYVwiOyAvLyBCbHVlXHJcblxyXG4gICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLm1lc3NhZ2UsIGN0eC5jYW52YXMud2lkdGggLyAyLCAxNTApO1xyXG5cclxuICAgICAgICAvLyBDb25uZWN0aW9ucyAmIFBhY2tldHNcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLmZvckVhY2goY29ubiA9PiB7XHJcbiAgICAgICAgICAgIC8vIERyYXcgTGluZVxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY29ubi5mcm9tLngsIGNvbm4uZnJvbS55KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhjb25uLnRvLngsIGNvbm4udG8ueSk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpXCI7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IFBhY2tldFxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50WCA9IGNvbm4uZnJvbS54ICsgKGNvbm4udG8ueCAtIGNvbm4uZnJvbS54KSAqIGNvbm4ucHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRZID0gY29ubi5mcm9tLnkgKyAoY29ubi50by55IC0gY29ubi5mcm9tLnkpICogY29ubi5wcm9ncmVzcztcclxuXHJcbiAgICAgICAgICAgIC8vIFBhY2tldCBHbG93XHJcbiAgICAgICAgICAgIGNvbnN0IGdsb3cgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoY3VycmVudFgsIGN1cnJlbnRZLCA1LCBjdXJyZW50WCwgY3VycmVudFksIDIwKTtcclxuICAgICAgICAgICAgZ2xvdy5hZGRDb2xvclN0b3AoMCwgXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpXCIpO1xyXG4gICAgICAgICAgICBnbG93LmFkZENvbG9yU3RvcCgxLCBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMClcIik7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBnbG93O1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoY3VycmVudFgsIGN1cnJlbnRZLCAyMCwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUGFja2V0IExhYmVsXHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZmZmZcIjtcclxuICAgICAgICAgICAgY3R4LmZvbnQgPSBcIjEycHggSW50ZXJcIjtcclxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGNvbm4ubGFiZWwsIGN1cnJlbnRYLCBjdXJyZW50WSAtIDIwKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gRHJhdyBEcmFnIExpbmVcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVOb2RlICYmIHRoaXMubW91c2VQb3MpIHtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMuYWN0aXZlTm9kZS54LCB0aGlzLmFjdGl2ZU5vZGUueSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5tb3VzZVBvcy54LCB0aGlzLm1vdXNlUG9zLnkpO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIiNmZmZmZmZcIjtcclxuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFs1LCA1XSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOb2Rlc1xyXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgLy8gTm9kZSBDaXJjbGVcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKG5vZGUueCwgbm9kZS55LCBub2RlLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG5cclxuICAgICAgICAgICAgLy8gRHluYW1pYyBub2RlIGNvbG9yaW5nXHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IFwiIzMzNDE1NVwiOyAvLyBEZWZhdWx0IFNsYXRlXHJcbiAgICAgICAgICAgIGxldCBnbG93Q29sb3IgPSBcInJnYmEoNTksIDEzMCwgMjQ2LCAwLjUpXCI7IC8vIEJsdWVcclxuXHJcbiAgICAgICAgICAgIC8vIEhpZ2hsaWdodCBzb3VyY2Ugbm9kZSBmb3IgY3VycmVudCBzdGVwXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnSURMRScgJiYgbm9kZS5pZCA9PT0gJ2FwcCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gXCIjM2I4MmY2XCI7IC8vIEJsdWVcclxuICAgICAgICAgICAgICAgIGdsb3dDb2xvciA9IFwicmdiYSg1OSwgMTMwLCAyNDYsIDAuOClcIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnQVVUSE9SSVpFRCcgJiYgbm9kZS5pZCA9PT0gJ2FwcCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gXCIjZjU5ZTBiXCI7IC8vIEFtYmVyIChoYXMgdG9rZW4pXHJcbiAgICAgICAgICAgICAgICBnbG93Q29sb3IgPSBcInJnYmEoMjQ1LCAxNTgsIDExLCAwLjgpXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5pZCA9PT0gJ2FwaScgJiYgdGhpcy5zdGF0ZSA9PT0gJ0NPTVBMRVRFJykge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBcIiMyMmM1NWVcIjsgLy8gR3JlZW5cclxuICAgICAgICAgICAgICAgIGdsb3dDb2xvciA9IFwicmdiYSgzNCwgMTk3LCA5NCwgMC44KVwiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHbG93IGFuaW1hdGlvblxyXG4gICAgICAgICAgICBjb25zdCBnbG93U2l6ZSA9IDEwICsgTWF0aC5zaW4odGhpcy50aW1lICogMykgKiA1O1xyXG4gICAgICAgICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChub2RlLngsIG5vZGUueSwgbm9kZS5yYWRpdXMsIG5vZGUueCwgbm9kZS55LCBub2RlLnJhZGl1cyArIGdsb3dTaXplKTtcclxuICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIGdsb3dDb2xvcik7XHJcbiAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBcInJnYmEoMCwwLDAsMClcIik7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKG5vZGUueCwgbm9kZS55LCBub2RlLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gQm9yZGVyXHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIExhYmVsXHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNjYmQ1ZTFcIjtcclxuICAgICAgICAgICAgY3R4LmZvbnQgPSBcIjE0cHggSW50ZXJcIjtcclxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KG5vZGUubGFiZWwsIG5vZGUueCwgbm9kZS55ICsgbm9kZS5yYWRpdXMgKyAyMCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJY29uL1RleHQgaW5zaWRlIG5vZGVcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgICAgICAgICAgY3R4LmZvbnQgPSBcImJvbGQgMTJweCBJbnRlclwiO1xyXG4gICAgICAgICAgICAvLyBTaW1wbGUgSW5pdGlhbHNcclxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbCA9IG5vZGUubGFiZWwuc3BsaXQoJyAnKS5tYXAodyA9PiB3WzBdKS5qb2luKCcnKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGluaXRpYWwsIG5vZGUueCwgbm9kZS55KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gSW5zdHJ1Y3Rpb25zIChNb3ZlZCB0byBCb3R0b20gTGVmdCwgc21hbGxlcilcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjNjQ3NDhiXCI7XHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xyXG4gICAgICAgIGN0eC5mb250ID0gXCIxNHB4IEludGVyXCI7XHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiSW5zdHJ1Y3Rpb25zOiBDbGljayBhbmQgZHJhZyB0byBjb25uZWN0IG5vZGVzLlwiLCAyMCwgY3R4LmNhbnZhcy5oZWlnaHQgLSAzMCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25DbGljayh4OiBudW1iZXIsIHk6IG51bWJlcikge1xyXG4gICAgICAgIC8vIFByZXZlbnQgaW50ZXJhY3Rpb24gaWYgYW5pbWF0aW5nXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdSRVFVRVNUSU5HJyB8fCB0aGlzLnN0YXRlID09PSAnSVNTVUlORycpIHJldHVybjtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0NPTVBMRVRFJykgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBjbGlja2VkTm9kZSA9IHRoaXMubm9kZXMuZmluZChub2RlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZHggPSBub2RlLnggLSB4O1xyXG4gICAgICAgICAgICBjb25zdCBkeSA9IG5vZGUueSAtIHk7XHJcbiAgICAgICAgICAgIHJldHVybiAoZHggKiBkeCArIGR5ICogZHkpIDwgKG5vZGUucmFkaXVzICogMiAqIG5vZGUucmFkaXVzICogMik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChjbGlja2VkTm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU1RBUlQgRFJBR1xyXG4gICAgICAgICAgICAgICAgLy8gRW5mb3JjZSBTdGFydCBOb2RlIGJhc2VkIG9uIFN0YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0lETEUnICYmIGNsaWNrZWROb2RlLmlkID09PSAnYXBwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZSA9IGNsaWNrZWROb2RlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnQVVUSE9SSVpFRCcgJiYgY2xpY2tlZE5vZGUuaWQgPT09ICdhcHAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlID0gY2xpY2tlZE5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFTkQgRFJBR1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlTm9kZSAhPT0gY2xpY2tlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBMb2dpY1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWxpZE1vdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFja2V0TGFiZWwgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYWNrZXRUeXBlOiBDb25uZWN0aW9uWyd0eXBlJ10gPSAncmVxdWVzdCc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1bGUgMTogSWRsZSAtPiBDb25uZWN0IEFwcCB0byBUZW5hbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0lETEUnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZS5pZCA9PT0gJ2FwcCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2tlZE5vZGUuaWQgPT09ICd0ZW5hbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkTW92ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2tldExhYmVsID0gXCJJRCArIFNlY3JldFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRUeXBlID0gJ3JlcXVlc3QnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1JFUVVFU1RJTkcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVsZSAyOiBBdXRob3JpemVkIC0+IENvbm5lY3QgQXBwIHRvIEFQSVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnQVVUSE9SSVpFRCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlLmlkID09PSAnYXBwJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlja2VkTm9kZS5pZCA9PT0gJ2FwaScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRNb3ZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFja2V0TGFiZWwgPSBcIkFjY2VzcyBUb2tlblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRUeXBlID0gJ2FjY2Vzcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnQUNDRVNTSU5HJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZE1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHRoaXMuYWN0aXZlTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBjbGlja2VkTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcGFja2V0VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBwYWNrZXRMYWJlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlID0gbnVsbDsgLy8gQ2FuY2VsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU5vZGUgPSBudWxsOyAvLyBDbGljayBlbXB0eSBzcGFjZSB0byBjYW5jZWxcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25Nb3VzZU1vdmUoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLm1vdXNlUG9zID0geyB4LCB5IH07XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYW51cCgpIHtcclxuICAgICAgICB0aGlzLm5vZGVzID0gW107XHJcbiAgICAgICAgdGhpcy5zdGFycyA9IFtdO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJDbGllbnRDcmVkZW50aWFsc0NvbnN0ZWxsYXRpb24iLCJpbml0IiwiY3R4Iiwid2lkdGgiLCJoZWlnaHQiLCJub2RlcyIsIngiLCJ5IiwibGFiZWwiLCJpZCIsInJhZGl1cyIsInN0YXJzIiwiaSIsInB1c2giLCJNYXRoIiwicmFuZG9tIiwic2l6ZSIsInNwZWVkIiwidXBkYXRlIiwiZHQiLCJ0aW1lIiwidXBkYXRlQ29uc3RlbGxhdGlvbiIsImNvbm5lY3Rpb25zIiwibGVuZ3RoIiwiY29ubiIsInByb2dyZXNzIiwiaGFuZGxlUGFja2V0QXJyaXZhbCIsInNwbGljZSIsInR5cGUiLCJ0byIsInN0YXRlIiwibWVzc2FnZSIsInNldFRpbWVvdXQiLCJhcHAiLCJmaW5kIiwibiIsInRlbmFudCIsImZyb20iLCJkcmF3IiwiZHJhd0NvbnN0ZWxsYXRpb24iLCJmaWxsU3R5bGUiLCJmb3JFYWNoIiwic3RhciIsIm9wYWNpdHkiLCJzaW4iLCJnbG9iYWxBbHBoYSIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbCIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJmaWxsVGV4dCIsImNhbnZhcyIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiY3VycmVudFgiLCJjdXJyZW50WSIsImdsb3ciLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsImFjdGl2ZU5vZGUiLCJtb3VzZVBvcyIsInNldExpbmVEYXNoIiwidGV4dEJhc2VsaW5lIiwibm9kZSIsImNvbG9yIiwiZ2xvd0NvbG9yIiwiZ2xvd1NpemUiLCJncmFkaWVudCIsImluaXRpYWwiLCJzcGxpdCIsIm1hcCIsInciLCJqb2luIiwib25DbGljayIsImNsaWNrZWROb2RlIiwiZHgiLCJkeSIsInZhbGlkTW92ZSIsInBhY2tldExhYmVsIiwicGFja2V0VHlwZSIsIm9uTW91c2VNb3ZlIiwiY2xlYW51cCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/game/ClientCredentialsConstellation.ts\n"));

/***/ })

});